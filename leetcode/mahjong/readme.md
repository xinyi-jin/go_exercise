## 核心算法思想: 

###  	预先生成表===>>用时直接查询

1. 找到所有能胡的牌型组合；

   所有能组成2张的对子，所有能组成3张的刻子和顺子。

   按照手牌张数 2，5,8,11,14 依次生成所有组合：

   2：

   ​	1万 1万

   ​	5万 5万
   ​	...

   5:

   ​	1万 1万 3万 3万 3万

   ​	5万 5万 2万 3万 4万

   ​	...

   以此类推。

   

2. 依次对单个牌型按照指定规则生成key值，写表；

   写表时key值有多种方式：

   日本优化内存写表方式：calcKey 最优写表方式，低内存，高性能

   直接写入手牌牌值方式：需排序  

   直接写入所有牌值对应牌张数据：内存消耗最大

3. 使用时候，直接计算判定牌型的key，到表中查取；

​	查表方式有两种：

1. 把所有手牌对应的形状一块生成key；
2. 分别把 筒条万生成对应的带将牌key，不带将牌key；字牌生成带将牌key，不带将牌key；

​	以上两种查表key生成方式均可以生成七对key表，以及生成任意癞子个数表； 可自行去除n张手牌生成；



### 先拆对子法(性能堪比查表)

	代码路径：https://github.com/yuanfengyun/qipai/tree/master/mjlib_lua/split

传统拆分法(不带赖子）
1、收集能做将的所有牌作为集合A
2、遍历每种能做将的牌，扣除后，判断剩余牌是否能胡
判断方法：遍历每种花色，从1到9按以下规则处理
a、如果遇到牌张数为0，continue
b、张数为1，判断以否扣除一坎牌，比如有一个2万，判断是否能组成2，3，4万，如果不能，则证明选择的这组将不能胡牌，break
c、张数为2，判断是否能扣除二坎牌，比如有2个6万，判断是否有7个七万和两个八万，如果不能，则证明选择的这组将不能胡牌 break
d、张数为3，直接扣除一个刻子
e、张数为4，扣除一个刻子后，判断是否能组成一坎牌，比如4个5万，先扣除3个5万，然后判断是否有5，6万各一张，如果有，则能组成三个四万，4，5，6万这两组牌，如果不能，则证明选择的这组将不能胡牌 break

示例：

1112345678999九莲宝灯牌型，判断是否能胡5万
1、将5万加入牌中, 11123455678999
2、选择将: 1万，5万，9万(大于等于2张的牌才能做将）

3、选择1万做将,剩余 123455678999
a、123455678999, 首部是1张1万，扣除123万，剩余455678999
b、455678999，首部是1张4万，扣除456万，剩余578999
c、578999，首部是1张5万，无法扣除567万，break

4、选择5万做将，剩余111234678999
a、111234678999，首部是3张1万，直接扣除，剩余234678999
b、234678999，首部是1张2万，扣除234，剩余678999
c、678999，首部是1张6万，扣除678，剩余999
d、999, 首部是3张9万，直接扣除，所有牌能拆完，胡牌

带赖子版本：
带赖子版本思路和传统拆分算法差不多，对1，3，4张牌的处理是完全一样的。
只是对于牌数量是2时，不能再直接拆222的组合，需要根据后面牌的情况，进行分类讨论
思路是一个赖子置换的贪心算法：

比如：
  当前是一个1万，
  如果我把这个1万配成一个刻子，需要2个赖子
  如果配成顺子的话，最坏c1=0,c2=0需要2个赖子，
  如果c1,c2中有一个不为0，则我只需要1个赖子，就可以配成顺子
  如果c1,c2中都不为0，则我不需要赖子就可以拆出顺子来, 这样可以节省两个赖子给后面的牌用

记号c，c1，c2，c3, c4分别表示当前牌个数，当前牌的后一张牌个数，后两张，后三张, 后四张牌的个数
比如 1万1万2万3万3万4万。c=2， c1=1, c2=2, c3=1, c4=0

具体分类如下：
c1 == 0 , 此时牌为20，如果拆222至少需要2个赖子，而拆3则只需要一张赖子，剩下胡赖子可以省下给后面用
c1 == 1 ，此时牌为21，需要根据后面的c2，c3来判断是拆刻子还是222，具体见代码
c2 == 2 , 此时牌为22, 如果拆33，需要2个赖子，拆222的话，可能需要0，1，2个赖子，选择拆222
c2 == 3 , c2 == 4的情况，见代码

​	

### 回溯算法（不推荐使用）
麻将有1-4张牌

不带癞子情况下的回溯算法：

1、一张牌的时候
   a、拆顺子{1,1,1}
2、二张牌的时候
   a、拆1对将 {2,0,0}
   b、拆两个顺子{2,2,2}
3、三张牌的时候
   a、拆1个刻子{3,0,0}
   b、1对将，1个顺子{3,1,1}
   c、3个顺子，和a是等价的
4、四张牌的时候
   a、拆1个刻子，1个顺子{4,1,1}
   b、拆1对将，2个顺子{4,2,2}
   c、4个顺子，和a是等价的

带癞子的回溯算法：

1、一张牌的时候
   a、拆顺子{1,1,1}
   b、拆将{1,0,0}
2、二张牌的时候
   a、拆1对将 {2,0,0}
   b、拆两个顺子{2,2,2}
   c、拆一个刻子{3,0,0}
3、三张牌的时候
   a、拆1个刻子{3,0,0}
   b、1对将，1个顺子{3,1,1}
   c、3个顺子，和a是等价的
4、四张牌的时候
   a、拆1个刻子，1个顺子{4,1,1}
   b、拆1对将，2个顺子{4,2,2}
   c、4个顺子，和a是等价的
   d、一对将，一个刻子{4,0,0}

chow文件夹下是随手写的一个吃牌判定，仅供参考使用；
